import "./chunk-BMTV3EA2.js";
import { parseGraphQLSDL } from "@graphql-tools/utils";
import debugFactory from "debug";
import { buildSchema, GraphQLError } from "graphql";
import { convertToESTree, extractComments, extractTokens } from "./estree-converter/index.js";
import { loadGraphQLConfig } from "./graphql-config.js";
import { getSchema } from "./schema.js";
import { getSiblings } from "./siblings.js";
import { CWD, VIRTUAL_DOCUMENT_REGEX } from "./utils.js";
const debug = debugFactory("graphql-eslint:parser");
debug("cwd %o", CWD);
function parseForESLint(code, options) {
  var _a, _b;
  try {
    const { filePath } = options;
    options.documents || (options.documents = options.operations);
    const { document } = parseGraphQLSDL(filePath, code, {
      ...options.graphQLParserOptions,
      noLocation: false
    });
    const gqlConfig = loadGraphQLConfig(options);
    const realFilepath = filePath.replace(VIRTUAL_DOCUMENT_REGEX, "");
    const project = gqlConfig.getProjectForFile(realFilepath);
    let schema = null;
    try {
      schema = project ? getSchema(project, options.schemaOptions) : typeof options.schema === "string" ? buildSchema(options.schema) : null;
    } catch (error) {
      if (error instanceof Error) {
        error.message = `Error while loading schema: ${error.message}`;
      }
      throw error;
    }
    const rootTree = convertToESTree(document, schema);
    return {
      services: {
        schema,
        siblingOperations: getSiblings(project, options.documents)
      },
      ast: {
        comments: extractComments(document.loc),
        tokens: extractTokens(filePath, code),
        loc: rootTree.loc,
        range: rootTree.range,
        type: "Program",
        sourceType: "script",
        body: [rootTree]
      }
    };
  } catch (error) {
    if (error instanceof Error) {
      error.message = `[graphql-eslint] ${error.message}`;
    }
    if (error instanceof GraphQLError) {
      const location = (_a = error.locations) == null ? void 0 : _a[0];
      const eslintError = {
        index: (_b = error.positions) == null ? void 0 : _b[0],
        ...location && {
          lineNumber: location.line,
          column: location.column - 1
        },
        message: error.message
      };
      throw eslintError;
    }
    throw error;
  }
}
export {
  parseForESLint
};
