"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var processor_exports = {};
__export(processor_exports, {
  processor: () => processor
});
module.exports = __toCommonJS(processor_exports);
var import_path = require("path");
var import_graphql_tag_pluck = require("@graphql-tools/graphql-tag-pluck");
var import_utils = require("@graphql-tools/utils");
var import_graphql_config2 = require("./graphql-config.js");
var import_utils2 = require("./utils.js");
const blocksMap = /* @__PURE__ */ new Map();
let onDiskConfig;
let onDiskConfigLoaded = false;
const RELEVANT_KEYWORDS = ["gql", "graphql", "GraphQL"];
const processor = {
  supportsAutofix: true,
  preprocess(code, filePath) {
    if (!onDiskConfigLoaded) {
      onDiskConfig = (0, import_graphql_config2.loadOnDiskGraphQLConfig)(filePath);
      onDiskConfigLoaded = true;
    }
    let keywords = RELEVANT_KEYWORDS;
    const pluckConfig = onDiskConfig == null ? void 0 : onDiskConfig.getProjectForFile(filePath).extensions.pluckConfig;
    if (pluckConfig) {
      const {
        modules = [],
        globalGqlIdentifierName = ["gql", "graphql"],
        gqlMagicComment = "GraphQL"
      } = pluckConfig;
      keywords = [
        ...new Set(
          [
            ...modules.map(({ identifier }) => identifier),
            ...(0, import_utils.asArray)(globalGqlIdentifierName),
            gqlMagicComment
          ].filter(import_utils2.truthy)
        )
      ];
    }
    if (keywords.every((keyword) => !code.includes(keyword))) {
      return [code];
    }
    try {
      const sources = (0, import_graphql_tag_pluck.gqlPluckFromCodeStringSync)(filePath, code, {
        skipIndent: true,
        ...pluckConfig
      });
      const blocks = sources.map((item) => ({
        filename: "document.graphql",
        text: item.body,
        lineOffset: item.locationOffset.line - 1,
        // @ts-expect-error -- `index` field exist but show ts error
        offset: item.locationOffset.index + 1
      }));
      blocksMap.set(filePath, blocks);
      return [
        ...blocks,
        code
        /* source code must be provided and be last */
      ];
    } catch (error) {
      if (error instanceof Error) {
        error.message = `[graphql-eslint] Error while preprocessing "${(0, import_path.relative)(
          import_utils2.CWD,
          filePath
        )}" file

${error.message}`;
      }
      console.error(error);
      return [code];
    }
  },
  postprocess(messages, filePath) {
    const blocks = blocksMap.get(filePath) || [];
    for (let i = 0; i < blocks.length; i += 1) {
      const { lineOffset, offset } = blocks[i];
      for (const message of messages[i] || []) {
        const isVueOrSvelte = /\.(vue|svelte)$/.test(filePath);
        if (isVueOrSvelte) {
          delete message.endLine;
          delete message.endColumn;
          delete message.fix;
          delete message.suggestions;
          Object.assign(message, import_utils2.REPORT_ON_FIRST_CHARACTER);
          continue;
        }
        message.line += lineOffset;
        if (typeof message.endLine === "number") {
          message.endLine += lineOffset;
        }
        if (message.fix) {
          message.fix.range[0] += offset;
          message.fix.range[1] += offset;
        }
        for (const suggestion of message.suggestions || []) {
          const [start, end] = suggestion.fix.range;
          suggestion.fix.range = [start + offset, end + offset];
        }
      }
    }
    const result = messages.flat();
    return result.sort((a, b) => a.line - b.line || a.column - b.column);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  processor
});
