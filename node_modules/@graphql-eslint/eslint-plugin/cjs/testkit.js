"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var testkit_exports = {};
__export(testkit_exports, {
  GraphQLRuleTester: () => GraphQLRuleTester
});
module.exports = __toCommonJS(testkit_exports);
var import_fs = require("fs");
var import_path = require("path");
var import_code_frame = require("@babel/code-frame");
var import_eslint = require("eslint");
function indentCode(code, indent = 4) {
  return code.replace(/^/gm, " ".repeat(indent));
}
function applyFix(code, { range, text }) {
  return [code.slice(0, range[0]), text, code.slice(range[1])].join("");
}
class GraphQLRuleTester extends import_eslint.RuleTester {
  constructor(parserOptions = {}) {
    const config = {
      parser: require.resolve("@graphql-eslint/eslint-plugin"),
      parserOptions: {
        ...parserOptions,
        skipGraphQLConfig: true
      }
    };
    super(config);
    this.config = config;
  }
  fromMockFile(path) {
    return (0, import_fs.readFileSync)((0, import_path.resolve)(__dirname, `../tests/mocks/${path}`), "utf-8");
  }
  runGraphQLTests(ruleId, rule, tests) {
    super.run(ruleId, rule, tests);
    const linter = new import_eslint.Linter();
    linter.defineRule(ruleId, rule);
    const hasOnlyTest = [...tests.valid, ...tests.invalid].some(
      (t) => typeof t !== "string" && t.only
    );
    for (const [idx, testCase] of tests.invalid.entries()) {
      const { only, filename, options, name } = testCase;
      if (hasOnlyTest && !only) {
        continue;
      }
      const code = removeTrailingBlankLines(testCase.code);
      const verifyConfig = getVerifyConfig(ruleId, this.config, testCase);
      defineParser(linter, verifyConfig.parser);
      const messages = linter.verify(code, verifyConfig, filename);
      if (messages.length === 0) {
        throw new Error("Invalid case should have at least one error.");
      }
      const codeFrame = indentCode(printCode(code, { line: 0, column: 0 }));
      const messageForSnapshot = ["#### \u2328\uFE0F Code", codeFrame];
      if (options) {
        const opts = JSON.stringify(options, null, 2).slice(1, -1);
        messageForSnapshot.push("#### \u2699\uFE0F Options", indentCode(removeTrailingBlankLines(opts), 2));
      }
      for (const [index, message] of messages.entries()) {
        if (message.fatal) {
          throw new Error(message.message);
        }
        const codeWithMessage = printCode(code, message, 1);
        messageForSnapshot.push(
          printWithIndex("#### \u274C Error", index, messages.length),
          indentCode(codeWithMessage)
        );
        if (message.suggestions && (code.match(/\n/g) || "").length < 1e3) {
          for (const [i, suggestion] of message.suggestions.entries()) {
            const title = printWithIndex(
              "#### \u{1F4A1} Suggestion",
              i,
              message.suggestions.length,
              suggestion.desc
            );
            const output = applyFix(code, suggestion.fix);
            const codeFrame2 = printCode(output, { line: 0, column: 0 });
            messageForSnapshot.push(title, indentCode(codeFrame2, 2));
          }
        }
      }
      if (rule.meta.fixable) {
        const { fixed, output } = linter.verifyAndFix(code, verifyConfig, filename);
        if (fixed) {
          messageForSnapshot.push("#### \u{1F527} Autofix output", indentCode(printCode(output)));
        }
      }
      it(name || `Invalid #${idx + 1}`, () => {
        expect(messageForSnapshot.join("\n\n")).toMatchSnapshot();
      });
    }
  }
}
function removeTrailingBlankLines(text) {
  return text.replace(/^\s*\n/, "").trimEnd();
}
function printWithIndex(title, index, total, description) {
  if (total > 1) {
    title += ` ${index + 1}/${total}`;
  }
  if (description) {
    title += `: ${description}`;
  }
  return title;
}
function getVerifyConfig(ruleId, testerConfig, testCase) {
  const { parser = testerConfig.parser, parserOptions, options } = testCase;
  return {
    ...testerConfig,
    parser,
    parserOptions: {
      ...testerConfig.parserOptions,
      ...parserOptions
    },
    rules: {
      [ruleId]: Array.isArray(options) ? ["error", ...options] : "error"
    }
  };
}
const parsers = /* @__PURE__ */ new WeakMap();
function defineParser(linter, parser) {
  if (!parser) {
    return;
  }
  if (!parsers.has(linter)) {
    parsers.set(linter, /* @__PURE__ */ new Set());
  }
  const defined = parsers.get(linter);
  if (!defined.has(parser)) {
    defined.add(parser);
    linter.defineParser(parser, require(parser));
  }
}
function printCode(code, result = {}, linesOffset = Number.POSITIVE_INFINITY) {
  const { line, column, endLine, endColumn, message } = result;
  const location = {};
  if (typeof line === "number" && typeof column === "number") {
    location.start = {
      line,
      column
    };
  }
  if (typeof endLine === "number" && typeof endColumn === "number") {
    location.end = {
      line: endLine,
      column: endColumn
    };
  }
  return (0, import_code_frame.codeFrameColumns)(code, location, {
    linesAbove: linesOffset,
    linesBelow: linesOffset,
    message
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GraphQLRuleTester
});
