"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var siblings_exports = {};
__export(siblings_exports, {
  getSiblings: () => getSiblings
});
module.exports = __toCommonJS(siblings_exports);
var import_utils = require("@graphql-tools/utils");
var import_graphql = require("graphql");
var import_documents = require("./documents.js");
var import_utils2 = require("./utils.js");
const siblingOperationsCache = /* @__PURE__ */ new Map();
function getSiblings(project, documents) {
  const siblings = project ? (0, import_documents.getDocuments)(project) : typeof documents === "string" ? [(0, import_utils.parseGraphQLSDL)("operation.graphql", documents, { noLocation: true })] : [];
  if (siblings.length === 0) {
    let printed = false;
    const noopWarn = () => {
      if (!printed) {
        import_utils2.logger.warn(
          'getSiblingOperations was called without any operations. Make sure to set "parserOptions.operations" to make this feature available!'
        );
        printed = true;
      }
      return [];
    };
    return {
      available: false,
      getFragment: noopWarn,
      getFragments: noopWarn,
      getFragmentByType: noopWarn,
      getFragmentsInUse: noopWarn,
      getOperation: noopWarn,
      getOperations: noopWarn,
      getOperationByType: noopWarn
    };
  }
  const value = siblingOperationsCache.get(siblings);
  if (value) {
    return value;
  }
  let fragmentsCache = null;
  const getFragments = () => {
    var _a;
    if (fragmentsCache === null) {
      const result = [];
      for (const source of siblings) {
        for (const definition of ((_a = source.document) == null ? void 0 : _a.definitions) || []) {
          if (definition.kind === import_graphql.Kind.FRAGMENT_DEFINITION) {
            result.push({
              filePath: source.location,
              document: definition
            });
          }
        }
      }
      fragmentsCache = result;
    }
    return fragmentsCache;
  };
  let cachedOperations = null;
  const getOperations = () => {
    var _a;
    if (cachedOperations === null) {
      const result = [];
      for (const source of siblings) {
        for (const definition of ((_a = source.document) == null ? void 0 : _a.definitions) || []) {
          if (definition.kind === import_graphql.Kind.OPERATION_DEFINITION) {
            result.push({
              filePath: source.location,
              document: definition
            });
          }
        }
      }
      cachedOperations = result;
    }
    return cachedOperations;
  };
  const getFragment = (name) => getFragments().filter((f) => f.document.name.value === name);
  const collectFragments = (selectable, recursive, collected = /* @__PURE__ */ new Map()) => {
    (0, import_graphql.visit)(selectable, {
      FragmentSpread(spread) {
        const fragmentName = spread.name.value;
        const [fragment] = getFragment(fragmentName);
        if (!fragment) {
          import_utils2.logger.warn(
            `Unable to locate fragment named "${fragmentName}", please make sure it's loaded using "parserOptions.operations"`
          );
          return;
        }
        if (!collected.has(fragmentName)) {
          collected.set(fragmentName, fragment.document);
          if (recursive) {
            collectFragments(fragment.document, recursive, collected);
          }
        }
      }
    });
    return collected;
  };
  const siblingOperations = {
    available: true,
    getFragment,
    getFragments,
    getFragmentByType: (typeName) => getFragments().filter((f) => f.document.typeCondition.name.value === typeName),
    getFragmentsInUse: (selectable, recursive = true) => Array.from(collectFragments(selectable, recursive).values()),
    getOperation: (name) => getOperations().filter((o) => {
      var _a;
      return ((_a = o.document.name) == null ? void 0 : _a.value) === name;
    }),
    getOperations,
    getOperationByType: (type) => getOperations().filter((o) => o.document.operation === type)
  };
  siblingOperationsCache.set(siblings, siblingOperations);
  return siblingOperations;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getSiblings
});
