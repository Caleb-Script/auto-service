"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  ARRAY_DEFAULT_OPTIONS: () => ARRAY_DEFAULT_OPTIONS,
  CWD: () => CWD,
  REPORT_ON_FIRST_CHARACTER: () => REPORT_ON_FIRST_CHARACTER,
  TYPES_KINDS: () => TYPES_KINDS,
  VIRTUAL_DOCUMENT_REGEX: () => VIRTUAL_DOCUMENT_REGEX,
  camelCase: () => camelCase,
  convertCase: () => convertCase,
  displayNodeName: () => displayNodeName,
  englishJoinWords: () => englishJoinWords,
  getLocation: () => getLocation,
  getNodeName: () => getNodeName,
  getTypeName: () => getTypeName,
  logger: () => logger,
  normalizePath: () => normalizePath,
  pascalCase: () => pascalCase,
  requireGraphQLSchemaFromContext: () => requireGraphQLSchemaFromContext,
  requireSiblingsOperations: () => requireSiblingsOperations,
  truthy: () => truthy
});
module.exports = __toCommonJS(utils_exports);
var import_chalk = __toESM(require("chalk"));
var import_graphql = require("graphql");
var import_lodash = __toESM(require("lodash.lowercase"));
function requireSiblingsOperations(ruleId, context) {
  const { siblingOperations } = context.parserServices;
  if (!siblingOperations.available) {
    throw new Error(
      `Rule \`${ruleId}\` requires \`parserOptions.operations\` to be set and loaded. See https://bit.ly/graphql-eslint-operations for more info`
    );
  }
  return siblingOperations;
}
function requireGraphQLSchemaFromContext(ruleId, context) {
  const { schema } = context.parserServices;
  if (!schema) {
    throw new Error(
      `Rule \`${ruleId}\` requires \`parserOptions.schema\` to be set and loaded. See https://bit.ly/graphql-eslint-schema for more info`
    );
  }
  return schema;
}
const logger = {
  error: (...args) => (
    // eslint-disable-next-line no-console
    console.error(import_chalk.default.red("error"), "[graphql-eslint]", (0, import_chalk.default)(...args))
  ),
  warn: (...args) => (
    // eslint-disable-next-line no-console
    console.warn(import_chalk.default.yellow("warning"), "[graphql-eslint]", (0, import_chalk.default)(...args))
  )
};
const normalizePath = (path) => (path || "").replace(/\\/g, "/");
const VIRTUAL_DOCUMENT_REGEX = /\/\d+_document.graphql$/;
const CWD = process.cwd();
const getTypeName = (node) => "type" in node ? getTypeName(node.type) : "name" in node && node.name ? node.name.value : "";
const TYPES_KINDS = [
  import_graphql.Kind.OBJECT_TYPE_DEFINITION,
  import_graphql.Kind.INTERFACE_TYPE_DEFINITION,
  import_graphql.Kind.ENUM_TYPE_DEFINITION,
  import_graphql.Kind.SCALAR_TYPE_DEFINITION,
  import_graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,
  import_graphql.Kind.UNION_TYPE_DEFINITION
];
const pascalCase = (str) => (0, import_lodash.default)(str).split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join("");
const camelCase = (str) => {
  const result = pascalCase(str);
  return result.charAt(0).toLowerCase() + result.slice(1);
};
const convertCase = (style, str) => {
  switch (style) {
    case "camelCase":
      return camelCase(str);
    case "PascalCase":
      return pascalCase(str);
    case "snake_case":
      return (0, import_lodash.default)(str).replace(/ /g, "_");
    case "UPPER_CASE":
      return (0, import_lodash.default)(str).replace(/ /g, "_").toUpperCase();
    case "kebab-case":
      return (0, import_lodash.default)(str).replace(/ /g, "-");
  }
};
function getLocation(start, fieldName = "") {
  const { line, column } = start;
  return {
    start: {
      line,
      column
    },
    end: {
      line,
      column: column + fieldName.length
    }
  };
}
const REPORT_ON_FIRST_CHARACTER = { column: 0, line: 1 };
const ARRAY_DEFAULT_OPTIONS = {
  type: "array",
  uniqueItems: true,
  minItems: 1,
  items: {
    type: "string"
  }
};
const englishJoinWords = (words) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(words);
function truthy(value) {
  return !!value;
}
const DisplayNodeNameMap = {
  [import_graphql.Kind.OBJECT_TYPE_DEFINITION]: "type",
  [import_graphql.Kind.OBJECT_TYPE_EXTENSION]: "type",
  [import_graphql.Kind.INTERFACE_TYPE_DEFINITION]: "interface",
  [import_graphql.Kind.INTERFACE_TYPE_EXTENSION]: "interface",
  [import_graphql.Kind.ENUM_TYPE_DEFINITION]: "enum",
  [import_graphql.Kind.ENUM_TYPE_EXTENSION]: "enum",
  [import_graphql.Kind.SCALAR_TYPE_DEFINITION]: "scalar",
  [import_graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION]: "input",
  [import_graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION]: "input",
  [import_graphql.Kind.UNION_TYPE_DEFINITION]: "union",
  [import_graphql.Kind.UNION_TYPE_EXTENSION]: "union",
  [import_graphql.Kind.DIRECTIVE_DEFINITION]: "directive",
  [import_graphql.Kind.FIELD_DEFINITION]: "field",
  [import_graphql.Kind.ENUM_VALUE_DEFINITION]: "enum value",
  [import_graphql.Kind.INPUT_VALUE_DEFINITION]: "input value",
  [import_graphql.Kind.ARGUMENT]: "argument",
  [import_graphql.Kind.VARIABLE]: "variable",
  [import_graphql.Kind.FRAGMENT_DEFINITION]: "fragment",
  [import_graphql.Kind.OPERATION_DEFINITION]: "operation",
  [import_graphql.Kind.FIELD]: "field"
};
function displayNodeName(node) {
  var _a, _b;
  return `${node.kind === import_graphql.Kind.OPERATION_DEFINITION ? node.operation : DisplayNodeNameMap[node.kind]} "${"alias" in node && ((_a = node.alias) == null ? void 0 : _a.value) || "name" in node && ((_b = node.name) == null ? void 0 : _b.value)}"`;
}
function getNodeName(node) {
  switch (node.kind) {
    case import_graphql.Kind.OBJECT_TYPE_DEFINITION:
    case import_graphql.Kind.OBJECT_TYPE_EXTENSION:
    case import_graphql.Kind.INTERFACE_TYPE_DEFINITION:
    case import_graphql.Kind.ENUM_TYPE_DEFINITION:
    case import_graphql.Kind.SCALAR_TYPE_DEFINITION:
    case import_graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case import_graphql.Kind.UNION_TYPE_DEFINITION:
    case import_graphql.Kind.DIRECTIVE_DEFINITION:
      return displayNodeName(node);
    case import_graphql.Kind.FIELD_DEFINITION:
    case import_graphql.Kind.INPUT_VALUE_DEFINITION:
    case import_graphql.Kind.ENUM_VALUE_DEFINITION:
      return `${displayNodeName(node)} in ${displayNodeName(node.parent)}`;
    case import_graphql.Kind.OPERATION_DEFINITION:
      return node.name ? displayNodeName(node) : node.operation;
  }
  return "";
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ARRAY_DEFAULT_OPTIONS,
  CWD,
  REPORT_ON_FIRST_CHARACTER,
  TYPES_KINDS,
  VIRTUAL_DOCUMENT_REGEX,
  camelCase,
  convertCase,
  displayNodeName,
  englishJoinWords,
  getLocation,
  getNodeName,
  getTypeName,
  logger,
  normalizePath,
  pascalCase,
  requireGraphQLSchemaFromContext,
  requireSiblingsOperations,
  truthy
});
