import { GraphQLParseOptions } from '@graphql-tools/utils';
import { RuleTester, Linter, Rule, AST } from 'eslint';
import * as ESTree from 'estree';
import { FragmentDefinitionNode, OperationDefinitionNode, SelectionSetNode, OperationTypeNode, ASTKindToNode, GraphQLSchema } from 'graphql';
import { GraphQLProjectConfig, IExtensions, IGraphQLProject } from 'graphql-config';
import { JSONSchema } from 'json-schema-to-ts';
import { GraphQLESTreeNode } from './estree-converter/types.js';

type FragmentSource = {
    filePath: string;
    document: FragmentDefinitionNode;
};
type OperationSource = {
    filePath: string;
    document: OperationDefinitionNode;
};
type SiblingOperations = {
    available: boolean;
    getFragment(fragmentName: string): FragmentSource[];
    getFragments(): FragmentSource[];
    getFragmentByType(typeName: string): FragmentSource[];
    getFragmentsInUse(baseOperation: FragmentDefinitionNode | OperationDefinitionNode | SelectionSetNode, recursive?: boolean): FragmentDefinitionNode[];
    getOperation(operationName: string): OperationSource[];
    getOperations(): OperationSource[];
    getOperationByType(operationType: OperationTypeNode): OperationSource[];
};
declare function getSiblings(project?: GraphQLProjectConfig, documents?: ParserOptions['documents']): SiblingOperations;

type GraphQLESLintRuleListener<WithTypeInfo extends boolean = false> = Record<string, any> & {
    [K in keyof ASTKindToNode]?: (node: GraphQLESTreeNode<ASTKindToNode[K], WithTypeInfo>) => void;
};
type GraphQLValidTestCase<Options = []> = Omit<RuleTester.ValidTestCase, 'options' | 'parserOptions'> & {
    options?: Options;
    parserOptions?: Omit<ParserOptions, 'filePath'>;
};
type GraphQLInvalidTestCase<T = []> = GraphQLValidTestCase<T> & {
    errors: (RuleTester.TestCaseError | string)[] | number;
    output?: string | null;
};
type RuleTesterConfig = {
    parser: string;
    parserOptions: Omit<ParserOptions, 'filePath'>;
};
declare class GraphQLRuleTester extends RuleTester {
    config: RuleTesterConfig;
    constructor(parserOptions?: Omit<ParserOptions, 'filePath'>);
    fromMockFile(path: string): string;
    runGraphQLTests<Options, WithTypeInfo extends boolean = false>(ruleId: string, rule: GraphQLESLintRule<Options, WithTypeInfo>, tests: {
        valid: (GraphQLValidTestCase<Options> | string)[];
        invalid: GraphQLInvalidTestCase<Options>[];
    }): void;
}

type Schema = GraphQLSchema | null;
type Pointer = string | string[];
interface ParserOptions {
    schema?: Pointer | Record<string, {
        headers: Record<string, string>;
    }>;
    documents?: Pointer;
    extensions?: IExtensions;
    include?: Pointer;
    exclude?: Pointer;
    projects?: Record<string, IGraphQLProject>;
    schemaOptions?: Omit<GraphQLParseOptions, 'assumeValidSDL'> & {
        headers: Record<string, string>;
    };
    graphQLParserOptions?: Omit<GraphQLParseOptions, 'noLocation'>;
    skipGraphQLConfig?: boolean;
    filePath: string;
    /** @deprecated Use `documents` instead */
    operations?: Pointer;
}
type ParserServices = {
    schema: Schema;
    siblingOperations: SiblingOperations;
};
type GraphQLESLintParseResult = Linter.ESLintParseResult & {
    services: ParserServices;
};
type Location = AST.SourceLocation | ESTree.Position;
type ReportDescriptorLocation = {
    loc: Location;
} | {
    node: {
        loc: Location;
    };
};
type ReportDescriptor = ReportDescriptorLocation & Rule.ReportDescriptorMessage & Rule.ReportDescriptorOptions;
type GraphQLESLintRuleContext<Options = any[]> = Omit<Rule.RuleContext, 'options' | 'parserServices' | 'report'> & {
    options: Options;
    parserServices: ParserServices;
    report(descriptor: ReportDescriptor): void;
};
type CategoryType = 'Operations' | 'Schema';
type RuleMetaDataDocs = Required<Rule.RuleMetaData>['docs'];
type RuleDocsInfo<T> = Omit<RuleMetaDataDocs, 'category' | 'suggestion'> & {
    category: CategoryType | CategoryType[];
    requiresSchema?: true;
    requiresSiblings?: true;
    examples?: {
        title: string;
        code: string;
        usage?: T;
    }[];
    configOptions?: T | {
        schema?: T;
        operations?: T;
    };
    graphQLJSRuleName?: string;
    isDisabledForAllConfig?: true;
};
type GraphQLESLintRule<Options = [], WithTypeInfo extends boolean = false> = {
    meta: Omit<Rule.RuleMetaData, 'docs' | 'schema'> & {
        docs?: RuleDocsInfo<Options>;
        schema: Readonly<JSONSchema> | [];
    };
    create(context: GraphQLESLintRuleContext<Options>): GraphQLESLintRuleListener<WithTypeInfo>;
};
type ValueOf<T> = T[keyof T];
type Id<T> = {
    [P in keyof T]: T[P];
} & {};
type OmitDistributive<T, K extends PropertyKey> = T extends object ? Id<OmitRecursively<T, K>> : T;
type OmitRecursively<T extends object, K extends PropertyKey> = Omit<{
    [P in keyof T]: OmitDistributive<T[P], K>;
}, K>;

export { CategoryType as C, FragmentSource as F, GraphQLESLintRuleListener as G, OmitRecursively as O, ParserOptions as P, ReportDescriptor as R, Schema as S, ValueOf as V, GraphQLValidTestCase as a, GraphQLInvalidTestCase as b, GraphQLRuleTester as c, Pointer as d, ParserServices as e, GraphQLESLintParseResult as f, GraphQLESLintRuleContext as g, RuleDocsInfo as h, GraphQLESLintRule as i, SiblingOperations as j, OperationSource as k, getSiblings as l };
