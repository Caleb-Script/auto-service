"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var relay_arguments_exports = {};
__export(relay_arguments_exports, {
  rule: () => rule
});
module.exports = __toCommonJS(relay_arguments_exports);
var import_graphql = require("graphql");
var import_utils = require("../utils.js");
const RULE_ID = "relay-arguments";
const MISSING_ARGUMENTS = "MISSING_ARGUMENTS";
const schema = {
  type: "array",
  maxItems: 1,
  items: {
    type: "object",
    additionalProperties: false,
    minProperties: 1,
    properties: {
      includeBoth: {
        type: "boolean",
        default: true,
        description: "Enforce including both forward and backward pagination arguments"
      }
    }
  }
};
const rule = {
  meta: {
    type: "problem",
    docs: {
      category: "Schema",
      description: [
        "Set of rules to follow Relay specification for Arguments.",
        "",
        "- A field that returns a Connection type must include forward pagination arguments (`first` and `after`), backward pagination arguments (`last` and `before`), or both",
        "",
        "Forward pagination arguments",
        "",
        "- `first` takes a non-negative integer",
        "- `after` takes the Cursor type",
        "",
        "Backward pagination arguments",
        "",
        "- `last` takes a non-negative integer",
        "- `before` takes the Cursor type"
      ].join("\n"),
      url: `https://the-guild.dev/graphql/eslint/rules/${RULE_ID}`,
      examples: [
        {
          title: "Incorrect",
          code: (
            /* GraphQL */
            `
            type User {
              posts: PostConnection
            }
          `
          )
        },
        {
          title: "Correct",
          code: (
            /* GraphQL */
            `
            type User {
              posts(after: String, first: Int, before: String, last: Int): PostConnection
            }
          `
          )
        }
      ],
      isDisabledForAllConfig: true
    },
    messages: {
      [MISSING_ARGUMENTS]: "A field that returns a Connection type must include forward pagination arguments (`first` and `after`), backward pagination arguments (`last` and `before`), or both."
    },
    schema
  },
  create(context) {
    const schema2 = (0, import_utils.requireGraphQLSchemaFromContext)(RULE_ID, context);
    const { includeBoth = true } = context.options[0] || {};
    return {
      "FieldDefinition > .gqlType Name[value=/Connection$/]"(node) {
        var _a;
        let fieldNode = node.parent;
        while (fieldNode.kind !== import_graphql.Kind.FIELD_DEFINITION) {
          fieldNode = fieldNode.parent;
        }
        const args = Object.fromEntries(
          ((_a = fieldNode.arguments) == null ? void 0 : _a.map((argument) => [argument.name.value, argument])) || []
        );
        const hasForwardPagination = !!(args.first && args.after);
        const hasBackwardPagination = !!(args.last && args.before);
        if (!hasForwardPagination && !hasBackwardPagination) {
          context.report({
            node: fieldNode.name,
            messageId: MISSING_ARGUMENTS
          });
          return;
        }
        function checkField(typeName, argumentName) {
          const argument = args[argumentName];
          const hasArgument = !!argument;
          let type = argument;
          if (hasArgument && type.gqlType.kind === import_graphql.Kind.NON_NULL_TYPE) {
            type = type.gqlType;
          }
          const isAllowedNonNullType = hasArgument && type.gqlType.kind === import_graphql.Kind.NAMED_TYPE && (type.gqlType.name.value === typeName || typeName === "String" && (0, import_graphql.isScalarType)(schema2.getType(type.gqlType.name.value)));
          if (!isAllowedNonNullType) {
            const returnType = typeName === "String" ? "String or Scalar" : typeName;
            context.report({
              node: (argument || fieldNode).name,
              message: hasArgument ? `Argument \`${argumentName}\` must return ${returnType}.` : `Field \`${fieldNode.name.value}\` must contain an argument \`${argumentName}\`, that return ${returnType}.`
            });
          }
        }
        if (includeBoth || args.first || args.after) {
          checkField("Int", "first");
          checkField("String", "after");
        }
        if (includeBoth || args.last || args.before) {
          checkField("Int", "last");
          checkField("String", "before");
        }
      }
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  rule
});
