"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var relay_page_info_exports = {};
__export(relay_page_info_exports, {
  rule: () => rule
});
module.exports = __toCommonJS(relay_page_info_exports);
var import_graphql = require("graphql");
var import_utils = require("../utils.js");
var import_relay_connection_types = require("./relay-connection-types.js");
const RULE_ID = "relay-page-info";
const MESSAGE_MUST_EXIST = "MESSAGE_MUST_EXIST";
const MESSAGE_MUST_BE_OBJECT_TYPE = "MESSAGE_MUST_BE_OBJECT_TYPE";
const notPageInfoTypesSelector = `:matches(${import_relay_connection_types.NON_OBJECT_TYPES})[name.value=PageInfo] > .name`;
let hasPageInfoChecked = false;
const rule = {
  meta: {
    type: "problem",
    docs: {
      category: "Schema",
      description: [
        "Set of rules to follow Relay specification for `PageInfo` object.",
        "",
        "- `PageInfo` must be an Object type",
        "- `PageInfo` must contain fields `hasPreviousPage` and `hasNextPage`, that return non-null Boolean",
        "- `PageInfo` must contain fields `startCursor` and `endCursor`, that return either String or Scalar, which can be null if there are no results"
      ].join("\n"),
      url: `https://the-guild.dev/graphql/eslint/rules/${RULE_ID}`,
      examples: [
        {
          title: "Correct",
          code: (
            /* GraphQL */
            `
            type PageInfo {
              hasPreviousPage: Boolean!
              hasNextPage: Boolean!
              startCursor: String
              endCursor: String
            }
          `
          )
        }
      ],
      isDisabledForAllConfig: true,
      requiresSchema: true
    },
    messages: {
      [MESSAGE_MUST_EXIST]: "The server must provide a `PageInfo` object.",
      [MESSAGE_MUST_BE_OBJECT_TYPE]: "`PageInfo` must be an Object type."
    },
    schema: []
  },
  create(context) {
    const schema = (0, import_utils.requireGraphQLSchemaFromContext)(RULE_ID, context);
    if (!hasPageInfoChecked) {
      const pageInfoType = schema.getType("PageInfo");
      if (!pageInfoType) {
        context.report({
          loc: import_utils.REPORT_ON_FIRST_CHARACTER,
          messageId: MESSAGE_MUST_EXIST
        });
      }
      hasPageInfoChecked = true;
    }
    return {
      [notPageInfoTypesSelector](node) {
        context.report({ node, messageId: MESSAGE_MUST_BE_OBJECT_TYPE });
      },
      "ObjectTypeDefinition[name.value=PageInfo]"(node) {
        var _a;
        const fieldMap = Object.fromEntries(
          ((_a = node.fields) == null ? void 0 : _a.map((field) => [field.name.value, field])) || []
        );
        const checkField = (fieldName, typeName) => {
          const field = fieldMap[fieldName];
          let isAllowedType = false;
          if (field) {
            const type = field.gqlType;
            if (typeName === "Boolean") {
              isAllowedType = type.kind === import_graphql.Kind.NON_NULL_TYPE && type.gqlType.kind === import_graphql.Kind.NAMED_TYPE && type.gqlType.name.value === "Boolean";
            } else if (type.kind === import_graphql.Kind.NAMED_TYPE) {
              isAllowedType = type.name.value === "String" || (0, import_graphql.isScalarType)(schema.getType(type.name.value));
            }
          }
          if (!isAllowedType) {
            const returnType = typeName === "Boolean" ? "non-null Boolean" : "either String or Scalar, which can be null if there are no results";
            context.report({
              node: field ? field.name : node.name,
              message: field ? `Field \`${fieldName}\` must return ${returnType}.` : `\`PageInfo\` must contain a field \`${fieldName}\`, that return ${returnType}.`
            });
          }
        };
        checkField("hasPreviousPage", "Boolean");
        checkField("hasNextPage", "Boolean");
        checkField("startCursor", "String");
        checkField("endCursor", "String");
      }
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  rule
});
