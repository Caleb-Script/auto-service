"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var no_unreachable_types_exports = {};
__export(no_unreachable_types_exports, {
  rule: () => rule
});
module.exports = __toCommonJS(no_unreachable_types_exports);
var import_graphql = require("graphql");
var import_lodash = __toESM(require("lodash.lowercase"));
var import_utils = require("../utils.js");
const RULE_ID = "no-unreachable-types";
const KINDS = [
  import_graphql.Kind.DIRECTIVE_DEFINITION,
  import_graphql.Kind.OBJECT_TYPE_DEFINITION,
  import_graphql.Kind.OBJECT_TYPE_EXTENSION,
  import_graphql.Kind.INTERFACE_TYPE_DEFINITION,
  import_graphql.Kind.INTERFACE_TYPE_EXTENSION,
  import_graphql.Kind.SCALAR_TYPE_DEFINITION,
  import_graphql.Kind.SCALAR_TYPE_EXTENSION,
  import_graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,
  import_graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION,
  import_graphql.Kind.UNION_TYPE_DEFINITION,
  import_graphql.Kind.UNION_TYPE_EXTENSION,
  import_graphql.Kind.ENUM_TYPE_DEFINITION,
  import_graphql.Kind.ENUM_TYPE_EXTENSION
];
let reachableTypesCache;
const RequestDirectiveLocations = /* @__PURE__ */ new Set([
  import_graphql.DirectiveLocation.QUERY,
  import_graphql.DirectiveLocation.MUTATION,
  import_graphql.DirectiveLocation.SUBSCRIPTION,
  import_graphql.DirectiveLocation.FIELD,
  import_graphql.DirectiveLocation.FRAGMENT_DEFINITION,
  import_graphql.DirectiveLocation.FRAGMENT_SPREAD,
  import_graphql.DirectiveLocation.INLINE_FRAGMENT,
  import_graphql.DirectiveLocation.VARIABLE_DEFINITION
]);
function getReachableTypes(schema) {
  if (reachableTypesCache) {
    return reachableTypesCache;
  }
  const reachableTypes = /* @__PURE__ */ new Set();
  const collect = (node) => {
    const typeName = (0, import_utils.getTypeName)(node);
    if (reachableTypes.has(typeName)) {
      return;
    }
    reachableTypes.add(typeName);
    const type = schema.getType(typeName) || schema.getDirective(typeName);
    if ((0, import_graphql.isInterfaceType)(type)) {
      const { objects, interfaces } = schema.getImplementations(type);
      for (const { astNode } of [...objects, ...interfaces]) {
        (0, import_graphql.visit)(astNode, visitor);
      }
    } else if (type == null ? void 0 : type.astNode) {
      (0, import_graphql.visit)(type.astNode, visitor);
    }
  };
  const visitor = {
    InterfaceTypeDefinition: collect,
    ObjectTypeDefinition: collect,
    InputValueDefinition: collect,
    UnionTypeDefinition: collect,
    FieldDefinition: collect,
    Directive: collect,
    NamedType: collect
  };
  for (const type of [
    schema,
    // visiting SchemaDefinition node
    schema.getQueryType(),
    schema.getMutationType(),
    schema.getSubscriptionType()
  ]) {
    if (type == null ? void 0 : type.astNode) {
      (0, import_graphql.visit)(type.astNode, visitor);
    }
  }
  for (const node of schema.getDirectives()) {
    if (node.locations.some((location) => RequestDirectiveLocations.has(location))) {
      reachableTypes.add(node.name);
      for (const arg of node.args) {
        const argTypeName = "name" in arg.type && arg.type.name;
        if (argTypeName) {
          reachableTypes.add(argTypeName);
        }
      }
    }
  }
  reachableTypesCache = reachableTypes;
  return reachableTypesCache;
}
const rule = {
  meta: {
    messages: {
      [RULE_ID]: "{{ type }} `{{ typeName }}` is unreachable."
    },
    docs: {
      description: "Requires all types to be reachable at some level by root level fields.",
      category: "Schema",
      url: `https://the-guild.dev/graphql/eslint/rules/${RULE_ID}`,
      requiresSchema: true,
      examples: [
        {
          title: "Incorrect",
          code: (
            /* GraphQL */
            `
            type User {
              id: ID!
              name: String
            }

            type Query {
              me: String
            }
          `
          )
        },
        {
          title: "Correct",
          code: (
            /* GraphQL */
            `
            type User {
              id: ID!
              name: String
            }

            type Query {
              me: User
            }
          `
          )
        }
      ],
      recommended: true
    },
    type: "suggestion",
    schema: [],
    hasSuggestions: true
  },
  create(context) {
    const schema = (0, import_utils.requireGraphQLSchemaFromContext)(RULE_ID, context);
    const reachableTypes = getReachableTypes(schema);
    return {
      [`:matches(${KINDS}) > .name`](node) {
        const typeName = node.value;
        if (!reachableTypes.has(typeName)) {
          const type = (0, import_lodash.default)(node.parent.kind.replace(/(Extension|Definition)$/, ""));
          context.report({
            node,
            messageId: RULE_ID,
            data: {
              type: type[0].toUpperCase() + type.slice(1),
              typeName
            },
            suggest: [
              {
                desc: `Remove \`${typeName}\``,
                fix: (fixer) => fixer.remove(node.parent)
              }
            ]
          });
        }
      }
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  rule
});
